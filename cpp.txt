#include <iostream>                                     //Header File 

int main(){
    std::cout<<"Hello\n";                               //standard charachter output
    std::cout<<"World"<<std::endl;                      //endl ends line

    return 0;                                           // If we return 0 then there is no problem in code if returned -1 there is a problem
}


// Data Types

#include <iostream>

int main() {

    //int (whole number)
    int age = 21;
    int year = 2023;
 
    //double (number including decimal)
    double price = 10.99;
    double gpa = 2.5;

    //char (single character)
    char grade = 'A';
    char currency = '$';

    //boolean (true or false)
    bool student = false;
    bool power = true;
 
    //string (objects that represent a sequence of text)
    std::string name = "Saleem";
    std::string address = "3-150 Hafeezpet";

    std::cout << "Hello " << name << '\n';
    std::cout << "You are " << age << " years old";

    return 0;
}


// Const

// The Variable we do not want change can be stored using const. In const name of the variable should be in UPPER CASE
#include <iostream>

int main() {
    const double PI = 3.14159;
    //PI = 420.69; This will cause an error
    double radius = 10;
    double circumference = 2 * PI * radius;

    std::cout << circumference << "cm";

    return 0;
}


// Namespace

// Namespace provides a solution for preventing name conflicts in large projects. Each entity needs a unique name. A namespace allows for identically named entities as long as the name space are different

#include <iostream>
namespace first{
    int x = 1;
}
namespace second{
    int x = 2;
}
int main() {

    int x = 0;

    std::cout << x;
    std::cout << first::x;
    std::cout << second::x;

    return 0;
}

Output:
 0
 1 
 2

using namespace std below header can stop reusing of std in every operation
But std has a lot of functions So, we can use using (using namespace std::cout) for calling cout operations


// typedef
it is a reserved keyword used to create an additional name(alias) for another data type
for example :
 let there be a data type as
    std::vector<std::pair<std::string, int>>;
 for this we can use 
    typedef std::vector<std::pair<std::string, int>> pairlist_t;
and can call the data type like pairlist_t variable1 = xyz

typedef is largely replaced with using keyword because it largely suits templates

#include <iostream>

//typedef std::string text_t;
//typedef int number_t;
using text_t = std::string;
using number_t = int;

int main(){

    text_t firstName = "Syed";
    number_t age = 21;

    std::cout << firstName << '\n';
    std::cout << age << '\n';

    return 0;
}

arithmetic operations
#include <iostream>

int main() 
{
   int students = 20;

   addition
   ------------------
   students = students + 1;
   students+=1;
   students++;

   subtraction
   ------------------
   students = students - 1;
   students-=1;
   students--;

   multiplication
   ------------------
   students = students * 2;
   students*=2;

   division
   ------------------
   students = students / 2;
   students/=2;

   modulus
   ------------------
   int remainder = students % 3;
   std::cout << remainder;

   std::cout << students;

   return 0;
}


// Type Conversion

there are two types of data conversion
impicit--- done automatically
example if we divide float but the output variable is int so it changes the number in int and return int
and can be used to convert number into its ASCII value
explicit-- done manually

#include<iostream>
 
int main()
{
    // type conversion = conversion a value of one data type to another
    //                 Implicit = automatic
    //                 Explicit = precede value with new data type (int)

    int correct = 8;
    int questions = 10;
    double score = correct/(double)questions * 100;

    std::cout << score << "%";

    return 0;
}


Accepting inputs in c++

#include <iostream>

// cout << (insertion operator)
// cin >> (extraction operator)

int main() 
{
   std::string name;
   int age;

   std::cout << "What's your full name?: ";
   std::getline(std::cin >> std::ws, name);                     //if our input conatins some white spaces then we use getline function  and std::ws eliminates newline charachters for any whitespaces  before user input

   std::cout << "What's your age?: ";
   std::cin >> age;

   std::cout << "Hello " << name << '\n';
   std::cout << "You are " << age << " years old";

   return 0;
}


// Math Function
#include <iostream>
#include <cmath>                                //Contain Math Functions

int main() 
{
   double x = 3.99;
   double y = 4;
   double z;

   z = std::max(x, y);                          //Finds max value
   z = std::min(x, y);                          //Finds min value
   z = pow(2, 4);                               //Finds power   
   z = sqrt(9);                                 //Finds squareroot
   z = abs(-3);                                 //Absolute Value
   z = round(x);                                //Round up the Number
   z = ceil(x);                                 //Round up the Number and increases
   z = floor(x);                                //Round up the Number and decreases
    For more math functions---- cplusplus/reference/cmath/

   std::cout << z;

   return 0;
}


//If statement
#include <iostream>

int main() 
{
   int age;

   std::cout << "Enter your age: ";
   std::cin >> age;

   if(age >= 18){
      std::cout << "Welcome to the site!";
   }
   else if(age < 0){
      std::cout << "You haven't been born yet!";
   }
   else{
      std::cout << "You are not old enough to enter!";
   }

   return 0;
}

//Switch
#include <iostream>

int main() 
{
   char grade;

   std::cout << "What letter grade?: ";
   std::cin >> grade;

   switch(grade){
      case 'A':
         std::cout << "You did great!";
         break;
      case 'B':
         std::cout << "You did good";
         break;
      case 'C':
         std::cout << "You did okay";
         break;
      case 'D':
         std::cout << "You did not do good";
         break;
      case 'F':
         std::cout << "YOU FAILED!";
         break;
      default:
         std::cout << "Please only enter in a letter grade (A-F)";
   }

   return 0;
}


// ternary operator
ternary operator ?: = replacement to an if/else statement
   condition ? expression1 : expression2;
#include <iostream>

int main() 
{
   int grade = 50;
   grade >= 60 ? std::cout << "You pass!" : std::cout << "You fail!";

   int number = 9;
   number % 2 ? std::cout << "ODD" : std::cout << "EVEN";

   bool hungry = true;
   hungry ? std::cout << "You are hungry" : std::cout << "You are full";

   return 0;
}

// Logical operator
   && = check if two conditions are true
   || = check if at least one of two conditions is true
   !  = reverses the logical state of its operand

#include <iostream>

int main() 
{
   int temp;
   bool sunny = false;

   std::cout << "Enter the temperature: ";
   std::cin >> temp;

   if(temp > 0 && temp < 30){
      std::cout << "The temperature is good!\n";
   }
   else{
      std::cout << "The temperature is bad!\n";
   }

   if(temp <= 0  || temp >= 30){
      std::cout << "The temperature is bad!\n";
   }
   else{
      std::cout << "The temperature is good!\n";
   }

   if(!sunny){                                          //Generally if(sunny) means true but using ! checks for false
      std::cout << "It is cloudy outside!";
   }
   else{
      std::cout << "It is sunny outside!";
   }

   return 0;
}

// string methods
getline()                           //for white spaces input
.length()                           //retunrs length of the string
.empty()                            //To check if empty or not             
.clear()                            //clears
.append()                           //appends thestring with another string
.at()                               //returns index
.insert(index, "value to insert")   //inserts
.find()                             //finds the charachter and retuns index
.erase(0, 3)                        //Erase charachters from 0 to 3

For more cplusplus/reference/cstring

// While loop
#include <iostream>

int main() 
{
   std::string name;
   
   while(name.empty()){                 //until name is empty keeps on running
      std::cout << "Enter your name: ";
      std::getline(std::cin, name);
   }
   
   std::cout << "Hello " << name;

   return 0;
}

// Do while loop
#include <iostream>
 
int main()
{
   int number;

   do{
      std::cout << "Enter a positive #: ";
      std::cin >> number;
   }while(number < 0);

   std::cout << "The # is: " << number;

   return 0;
}

// For Loops
#include <iostream>
 
int main()
{
   for(int i = 10; i > 0; i--){
      //count down to 10
      std::cout << i << '\n';
   }
 
   std::cout << "HAPPY NEW YEAR!\n";  
 
   return 0;
}

// break and continue statement
#include <iostream>

int main()
{
    // break = break out of a loop
    // continue = skip current iteration

    for(int i = 1; i <= 20; i++){
        if(i == 12){
            //break;                    // breaks out of the loop
            //continue;                 // skips 12 and continue the loop
        }
        std::cout << i << '\n';
    }

    return 0;
}

// Nested loops
#include <iostream>
 
int main()
{
   int rows;
   int columns;
   char symbol;

   std::cout << "How many rows?: ";
   std::cin >> rows;

   std::cout << "How many columns?: ";
   std::cin >> columns;

   std::cout << "Enter a symbol to use: ";
   std::cin >> symbol;

   for(int i = 1; i <= rows; i++){
      for(int j = 1; j <= columns; j++){
         std::cout << symbol;
      }
      std::cout << '\n';
   }

   return 0;
}


//Random number
#include <iostream>

int main()
{
    srand(time(NULL));

    int num = rand();

    std::cout<<num;

    int num1 = (rand() % 6) + 1;
    int num2 = (rand() % 6) + 1;
    int num3 = (rand() % 6) + 1;

    std::cout << num1 << '\n';
    std::cout << num2 << '\n';
    std::cout << num3 << '\n';

    return 0;
}

//Random Event Generator
#include <iostream>
#include <ctime>

int main()
{
    srand(time(0));
    int randNum = rand() % 5 + 1;

    switch(randNum){
        case 1: std::cout << "You win a bumper sticker!\n";
                break;
        case 2: std::cout << "You win a t-shirt!\n";
                break;
        case 3: std::cout << "You win a free lunch!\n";
                break;
        case 4: std::cout << "You win a gift card!\n";
                break;
        case 5: std::cout << "You win concert tickets!\n";
                break;
    }

    return 0;
}

//Number Guessing Game
#include <iostream>

int main() {
    int num, guess, tries;
    srand(time(0));
    
    num = (rand()%100) + 1;
    
    do{
        std::cout<<"Guess the number: ";
        std::cin>>guess;
        
        if(guess>num)
        std::cout<<"To High\n";
        
        else if(guess<num)
        std::cout<<"To Low\n";
        
        else
        std::cout<<"\nCorrect Guess "<<guess;
        
        
    }while(guess!=num);
}

#include <iostream>

void happyBirthday(std::string name, int age);                      //to write function after the main function we declare it first so that there is no error while compileing it is known as function decoration

int main()
{
    // function = a block of reusable code

    std::string name = "Bro";
    int age = 21;

    happyBirthday(name, age);                                       //since function will not know whats going on in other functions we can send the variables as arguements

    return 0;
}
void happyBirthday(std::string name, int age){                      //The parameters should be same as arguement data types. It need not be of the same name (for example we send the arguement as name but we can give it another name in parameters it dosn't effect its value)
    std::cout << "Happy Birthday to " << name << '\n';
    std::cout << "Happy Birthday to " << name << '\n';
    std::cout << "Happy Birthday dear " << name << '\n';
    std::cout << "Happy Birthday to " << name << '\n';
    std::cout << "You are " << age << " years old!\n";
}

// return data type 
#include <iostream>

double square(double length);
double cube(double length);

int main()
{
    double length = 6.0;
    double area = square(length);
    double volume = cube(length);

    std::cout << "Area: " << area << "cm^2\n";
    std::cout << "Volume: " << volume << "cm^3\n";

    return 0;
}
double square(double length){                                       //since the function is returning a double data type to the main function we need to declare it as double function name                             
                                                                    //we can output what we want using void also but if we want the value to be sent to the main function we have to declare it with the value it returns
    return length * length;
}
double cube(double length){
    return length * length * length;
}


// Overloaded Functions 
Functions can have same fuction name with different set of parameters name 
function name + parameters is called function signature

#include <iostream>

void bakePizza();
void bakePizza(std::string topping1);
void bakePizza(std::string topping1, std::string topping2);

int main()
{
    bakePizza();
    bakePizza("pepperoni");
    bakePizza("pepperoni", "mushroom");

    return 0;
}

void bakePizza(){
    std::cout << "Here is your pizza!\n";
}
void bakePizza(std::string topping1){
    std::cout << "Here is your " << topping1 << " pizza!\n";
}
void bakePizza(std::string topping1, std::string topping2){
    std::cout << "Here is your " << topping1 << " and " << topping2 << " pizza!\n";
}


GLobal and Local variables 

#include <iostream>

int myNum = 3; //global

void printNum();

int main()
{
    int myNum = 1; //local
    printNum();
    std::cout << "main: " << myNum << '\n'; //local
    //std::cout << ::myNum << '\n'; //global                        //:: is scope resolution operator

    return 0;
}
void printNum(){
    int myNum = 2; //local
    std::cout << "printNum: "<< myNum << '\n'; //local
    //std::cout << ::myNum << '\n'; //global
}


// Rock Paper Scissor
#include <iostream>
#include <ctime>

char getUserChoice();
char getComputerChoice();
void showChoice(char choice);
void chooseWinner(char player, char computer);

int main() {

	char player;
	char computer;

	player = getUserChoice();
	std::cout << "Your choice: ";
	showChoice(player);

	computer = getComputerChoice();
	std::cout << "Computer's choice: ";
	showChoice(computer);

	chooseWinner(player, computer);
 
    return 0;
}
char getUserChoice(){

	char player;
	std::cout << "Rock-Paper-Scissors Game!\n";

	do{
		std::cout << "Choose one of the following\n";
		std::cout << "*************************\n";
		std::cout << "'r' for rock\n";
		std::cout << "'p' for paper\n";
		std::cout << "'s' for scissors\n";
		std::cin >> player;
	}while(player != 'r' && player != 'p' && player != 's');

	return player;
}
char getComputerChoice(){

	srand(time(0));
	int num = rand() % 3 + 1;

	switch(num){
		case 1: return 'r';
		case 2: return 'p';
		case 3: return 's';
	}

	return 0;
}
void showChoice(char choice){

	switch(choice){
		case 'r': std::cout << "Rock\n";
				  break;
		case 'p': std::cout << "Paper\n";
				  break;
		case 's': std::cout << "Scissors\n";
				  break;
	}
}
void chooseWinner(char player, char computer){

	switch(player){
		case 'r': 	if(computer == 'r'){
						std::cout << "It's a tie!\n";
					}
					else if(computer == 'p'){
						std::cout << "You lose!\n";
					}
					else{
						std::cout << "You win!\n";
					}
					break;
		case 'p': 	if(computer == 'r'){
						std::cout << "You win!\n";
					}
					else if(computer == 'p'){
						std::cout << "It's a tie!\n";
					}
					else{
						std::cout << "You lose!\n";
					}
					break;
		case 's': 	if(computer == 'r'){
						std::cout << "You lose!\n";
					}
					else if(computer == 'p'){
						std::cout << "You win!\n";
					}
					else{
						std::cout << "It's a tie!\n";
					}
					break;
	}
}


// Arrays
Arrays should of same data type only

#include <iostream>

int main()
{
    std::string cars[3] = {"Corvette", "Mustang", "Camry"};

    std::cout << cars[0] << '\n';
    std::cout << cars[1] << '\n';
    std::cout << cars[2] << '\n';

    return 0;
}

//Sizeof
sizeof int= 4 bytes,
sizeof double= 8 bytes,
sizeof string= 32 bytes,
sizeof char= 1 bytes,
sizeof boolean= 1 bytes,
sizeof array = number of charachters in the array

#include <iostream>

int main()
{
    // sizeof() = determines the size in bytes of a: 
    //                   variable, data type, class, objects, etc.

    std::string name = "Bro Code";
    double gpa = 2.5;
    char grade = 'F';
    bool student = true;
    char grades[] = {'A', 'B', 'C', 'D', 'F'};
    std::string students[] = {"Spongebob", "Patrick", "Squidward", "Sandy"};

    std::cout << sizeof(name) << " bytes\n";
    std::cout << sizeof(students)/sizeof(std::string) << " elements\n";
    
    return 0;
}

// iterating an array.
#include <iostream>

int main()
{
    //std::string students[] = {"Spongebob", "Patrick", "Squidward", "Sandy"};
    char grades[] = {'A', 'B', 'C', 'D', 'F'};

    for(int i = 0; i < sizeof(grades)/sizeof(grades[0]); i++){
        std::cout << grades[i] << '\n';
    }

    return 0;
}


//for each loop
#include <iostream>

int main()
{
    // foreach loop = loop that eases the traversal over an 
    //                            iterable data set

    int grades[] = {65, 72, 81, 93};

    for(int grade : grades){                                        //grade is variable to store the value for each iteration we can use abc also
        std::cout << grade << '\n';
    }

    return 0;
}

// function in array

#include <iostream>
 
double getTotal(double prices[], int size);
 
int main()
{
   double prices[] = {49.99, 15.05, 75, 9.99};      
   int size = sizeof(prices)/sizeof(prices[0]);                    //Since the array is passed in another function the function cannot find the size so we find the size and send it to the function  or we can send the pointer
   double total = getTotal(prices, size);
 
   std::cout << "The total is: $" << total;
 
   return 0;
}
double getTotal(double prices[], int size) 
{
    double total = 0;              
 
    for(int i = 0; i < size; i++){
        total += prices[i];
    }
 
    return total;
}

// Search  Array
#include<iostream>

int searchArray(std::string array[], int size, std::string element);

int main()
{
    std::string foods[] = {"pizza", "hamburger", "hotdog"};
    int size = sizeof(foods)/sizeof(foods[0]);
    int index;
    std::string myFood;

    std::cout << "Enter element to search for: " << '\n';
    std::getline(std::cin, myFood);

    index = searchArray(foods, size, myFood);

    if(index != -1){
        std::cout << myFood << " is at index " << index;
    }
    else{
        std::cout << myFood << " is not in the array";
    }

    return 0;
}
int searchArray(std::string array[], int size, std::string element){

    for(int i = 0; i < size; i++){
        if(array[i] == element){
            return i;
        }
    }
    return -1;
}


// Sorting an Array
using bubble sort ----- in bubble sort we compare the 2 consecutive elements and compare them with the help of a temporary variable we swap and sort them.  We continue this until the whole array is sorted 


#include <iostream>

void sort(int array[], int size);

int main()
{
	int array[] = {10, 1, 9, 2, 8, 3, 7, 4, 6, 5};
	int size = sizeof(array)/sizeof(array[0]);

	sort(array, size);

	for(int element : array){
		std::cout << element << " ";
	}

    return 0;
}
void sort(int array[], int size){
	int temp;
	for(int i = 0; i < size - 1; i++){
		for(int j = 0; j < size - i - 1; j++){
			if(array[j] < array[j + 1]){
				temp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = temp;
			}
		}
	}
}


// Fill Function
fill() -- Fills a range of elements with a specified value
            fill(begin, end, value)

#include <iostream>

int main(){
    const int SIZE = 100;
    std::string foods[SIZE];

    fill(foods, foods+SIZE, "pizza");                        //foods - starting point; foods+SIZE - Ending Point

    // fill(foods, foods+(SIZE/2), "pizza");                 // Fills half with pizza and half with hambuger
    // fill(foods+(SIZE/2), foods+SIZE, "hamburger");


    for(std::string food : foods)
        std::cout<<food<<' ';

    return 0;
}

// user input in array
#include<iostream>

int main(){
    std::string foods[5];
    int size = sizeof(foods)/sizeof(foods[0]);
    std::string temp;

    for(int i=0; i<size; i++){
        std::cout<<"Enter food you like or 'q' to quit #"<< i+1;
        std::getline(std::cin, temp);                               //if q is pressed we get out of the loop
        if(temp == "q"){
            break;
        }
        else{
            foods[i] = temp;
        }
    }

    std::cout<<"Your Foods are : \n";

    for(int i = 0; !foods[i].empty(); i++){                         //iterate till the array is empty
        std::cout<<foods[i]<<' ';
    }

    return 0;
}


// 2-D Arrays
#include <iostream>

int main(){
    std::string cars[][3] = {{"Mustang", "Escape", "f-150"},
                            {"coveta", "equinox", "silverado"},
                            {"challenger", "darngo", "ram150"}};

    int row = sizeof(cars)/sizeof(cars[0]);
    int columns = sizeof(cars[0])/sizeof(cars[0][0]);

    std::cout<<cars[0][2]<<'\n';

    for(int i=0; i<row; i++){
        for(int j=0; j<columns; j++){
            std::cout<<cars[i][j]<<' ';
        }
        std::cout<<'\n';
    }

    return 0;
}

// Quiz Game
#include<iostream>

int main(){
    std::string questions[] = {
        "1. What is the Capital of India? ",
        "2. What is the Capital of Telangana? ",
        "3. What is the National Animal? ",
        "4. What is the National Bird? "
    };

    std::string options[][4]{
        {"A. Mumbai", "B. Kolkata", "C. Chennai", "D. Delhi"},
        {"A. Warangal", "B. Khammam", "C. Hyderabad", "D. Kurnool"},
        {"A. Tiger", "B. Cheetah", "C. Peacock", "D. Lion"},
        {"A. Lotus", "B. Humming Bird", "C. Peacock", "D. Parrot"}
    };

    char answers[] = {'D', 'C', 'A', 'C'};

    int size = sizeof(questions)/sizeof(questions[0]);
    char guess;
    int score;

    for(int i=0; i<size; i++){
        std::cout<<"*********************"<<'\n';
        std::cout<<questions[i]<<'\n';
        std::cout<<"*********************"<<'\n';

        for(int j=0; j<sizeof(options[i])/sizeof(options[i][0]); j++){
            std::cout<<options[i][j]<<'\n';
        }

        std::cin>>guess;
        guess = toupper(guess);

        if(guess == answers[i]){
            std::cout<<"Correct\n";
            score++;
        }
        else{
            std::cout<<"Wrong\n";
            std::cout<<"Correct answer is: "<<answers[i]<<"\n";
        }
    }

    std::cout<<"**********************";
    std::cout<<"Score is"<<score<<"\n";
}


// Memory Address
memory address = a location in memory where data is stored 
a memory address ca nbe accessed with &(address-of operator)

#include<iostream>

int main(){
    std::sting name = "Saleem";
    int age = 20;
    bool student = true;

    std::cout<< &name <<'\n';                           
    std::cout<< &age <<'\n';
    std::cout<< &student <<'\n';                                //retuns the memory address of the corresponding variables in hexadecimal value

    return 0;
}


//Passby Value and Passby Reference
When we pass by value we create the copies of the value and pass it
But When we pass by reference we actually send the original value
Here when we first sent the values the original variable did not swapped only the cpies got swapped
But when we pass by reference they got swapped   (we passby reference by sending memory address '&')

#include<iostream>

// void swap(std::string x, std::string y);
void swap(std::string &x, std::string &y);


int main(){
    std::string x = "Kool-Aid";
    std::string y = "Water";

    swap(x, y);

    std::cout<<"X: "<< x <<"\n";
    std::cout<<"Y: "<< y <<"\n";

    return 0;
}

// void swap(std::string x, std::string y){
//     std::string temp;
//     temp = x;
//     x = y;
//     y = temp;                                            //This will not swap since we are passing values
// }

void swap(std::string &x, std::string &y){
    std::string temp;
    temp = x;
    x = y;
    y = temp;                                            //This will swap since we are passing reference to the memory address
}


// Const Parameter
const parameter -- parameter that is effectivel read-only
                    code is more secure and conveys intent 
                    useful for references and pointers

#include<iostream>

void printInfo(const std::string name, const int age);                //We use const parameter so that the value does not change in another funstion

int main(){
    std::string name = "Saleem";
    int age = 20;

    printInfo(name, age);

    return 0;
}

void printInfo(const std::string name, const int age){
    // name = "saleemuddin";
    // age ="19";                                   //This gives an error because we can not modify const parameters

    std::cout<<name<< '\n';
    std::cout<<age<< '\n';
}


// Credit Card Validator Program
for a valid credit card                                                                     6011 0009 9013 9424
1. Double every second digit from right to left If doubled digit is 2digit split it         1 2(6 double is 12 split it) 2(one double) 0 0 1 8(9 double) 2 1 8 4  
2. add all the single digits                                                                1+2+2+0+0+1+8+2+1+8+4 = 29
3. Now take odd digits from rigth to left   and add them                                    0 1 0 9 0 3 4 4 = 29          
4. sum result of step2 and step3                                                            21 + 29 = 50
5. This should be dividible by 10                                                           divisible by 10 so valid credit number

#include<iostream>

int getDigit(const int number);
int sumOddDigits(const std::string cardNumber);
int sumEvenDigits(const std::string cardNumber);

int main(){
    std::string cardNumber;
    int result = 0;

    std::cout<<"Enter the Card Number: "<<'\n';
    std::cin>>cardNumber;

    result = sumEvenDigits(cardNumber) + sumOddDigits(cardNumber);

    if(result % 10 == 0)
        std::cout<<"Valid Card Number\n";
    else        
        std::cout<<"invalid Card Number\n";

    return 0;
}

int getDigit(const int number){
    //18 18%10 = 8,       18/10 = 1 %10 =1   so we get 1+8=9
    return number %10 + (number/10 % 10);                                    //This will return the digits of the number that got 2 digit to sumEvenDigit
}

int sumOddDigits(const std::string cardNumber){
    int sum = 0;

    for(int i = cardNumber.size()-1; i>=0; i=-2){                            
        sum += (cardNumber[i] - '0') * 2;                          
    }

    return sum;
}

int sumEvenDigits(const std::string cardNumber){
    int sum = 0;

    for(int i = cardNumber.size()-2; i>=0; i=-2){                            //string last index is size-1  we want even so size-2
        sum += getDigit((cardNumber[i] - '0') * 2);                          // returns ASCII value so subtracting by ASCII value of 0 to get the number value
    }

    return sum;
}


// Pointers
pointer---- pointer variable stores a memory address of another variable

& -- address of operator
* -- dereference operator

#include<iostream>

int main(){
    
    std::string name = "Saleem";

    std::string *pName = &name;                                             //pname gets the address of name
                                                                            //for array we dont need to add & because array is already a memory address
    std::cout<<*pNname<<'/n';       

    return 0;
}


// Null Pointers
If a Pointer is holding a null value i.e., it is not pointing at anything

nullptr -- a keyword that represents a null pointer 

nullptr are usefull to determine whether the memory address is successfully assigned to the pointer or not

When using a pointer be careful that the code is not  dereferencing nullptr or pointing to free memory. This will cause undefined behavoiour

#include<iostream>

int main(){
    int *pointer = nullptr;
    int c = 203;

    *pointer = &c;

    if(pointer == nullptr){
        std::cout<<"Address is not assigned";
    }
    else
        std::cout<<"Address is assigned";
        std::cout<<"its value is : "<<*pointer;

    return 0;
}


// Dynamic Memory
dynamic Memory-- The memory which is allocated to after the program is already compiled and Runninng
                    use the word 'new' to allocate the memory in heap rather than the stack
                    useful when we don't  ' know how much memory our program need 

#include <iostream>

int main () {

    char *pGrades = NULL;
    int size;

    std::cout << "How many grades to enter in?: ";
    std::cin >> size;

    pGrades = new char[size];

    for(int i = 0; i < size; i++){
        std::cout << "Enter grade #" << i + 1 << ": ";
        std::cin >> pGrades[i];
    }

    for(int i = 0; i < size; i++){
        std::cout << pGrades[i] << " ";
    }

    delete[] pGrades;

    return 0;
}


// Recursion
Recursion --- recursion is a programming technique in which function invokes itself from within 
        Less code and cleaner, useful in searching, sorting
        But uses more memory and slower

// Iteration
#include<iostream>

void walk(int steps);

int main(){

    walk(10);
    return 0;
}

void walk(int steps){
    for (int i=0; i<steps; i++){
        std::cout<<"Walk"<<'\n';
    }
}

// Recursion -- in this we call the function within itself
#include<iostream>

void walk(int steps);

int main(){

    walk(10);
    return 0;
}

void walk(int steps){
    if(steps > 0){
        std::cout<<"walk"<<'\n';
        walk(steps-1);
    }
}

// recursion facorial
#include <iostream>
int factorial(int num);
int main () {

    std::cout << factorial(10);

    return 0;
}
int factorial(int num){
    if(num > 1){
        return num * factorial(num - 1);
    }
    else{
        return 1;
    }
}


// Function Template
function template --- describes what a function looks like
                    Can be used to overload as many as overloded function as needed, each using different datatypes

#include <iostream>
template <typename T>
T max(T x, T y){                                //We don,t need to describe the type of data like int double or char. The function works for all the data type. But the compiler needs to know what is T. template <typename T> is used to describe it
    return (x > y) ? x : y;
}
int main()
{
    std::cout << max(1, 2) << '\n';
    std::cout << max(1.1, 2.2) << '\n';
    std::cout << max('1', '2') << '\n';
 
    return 0;
}

the above can be used if we are sending two data of same data types. But if we want to send different data types we do----

#include <iostream>
template <typename T, typename U>                   //we declare both the data types
auto max(T x, U y){                                 //as in previous program we wrote T max(......) here max can be int or double or string data type so we we write auto so it output what ever the data type it is(in case we use T then double might be max but it returns that int value of that) 
    return (x > y) ? x : y;
}
int main()
{
    std::cout << max(1, 2.1) << '\n';
 
    return 0;
}


// Structs
struct --- A structure that group related variables under one name 
            structs can contain many different data types(string, int, double, bool, etc)
            variables in a struct are known as "members"
            members can be access with . "Class Member Access Operator"
	    
#include <iostream>

struct student{                                             //student is a identifier                                  
    std::string name;                                       //varibles declared in struct are members 
    double gpa;
    bool enrolled; 
    //bool enrolled = true;                                   //we can set them to a default value so that we need not need to declare them later                                         
};
int main()
{
    student student1;
    student1.name = "Spongebob";
    student1.gpa = 3.2;
    student1.enrolled = true;

    student student2;
    student2.name = "Patrick";
    student2.gpa = 2.1;
    student1.enrolled = true;


    student student3;
    student3.name = "Squidward";
    student3.gpa = 1.5;
    student1.enrolled = false;


    std::cout << student1.name << '\n';
    std::cout << student1.gpa << '\n';
    std::cout << student1.enrolled << '\n';

    std::cout << student2.name << '\n';
    std::cout << student2.gpa << '\n';
    std::cout << student2.enrolled << '\n';

    std::cout << student3.name << '\n';
    std::cout << student3.gpa << '\n';
    std::cout << student3.enrolled << '\n';

    return 0;
}


// Passing structs as arguement
#include <iostream>

struct Car{
    std::string model;
    int year;
    std::string color;
};

void printCar(Car &car);
void paintCar(Car &car, std::string color);

int main () {

    Car car1;
    Car car2;

    car1.model = "Mustang";
    car1.year = 2023;
    car1.color = "red";

    car2.model = "Corvette";
    car2.year = 2024;
    car2.color = "blue";

    paintCar(car1, "silver");
    paintCar(car2, "gold");

    printCar(car1);
    printCar(car2);

    return 0;
}
void printCar(Car &car){                                    //struct identifier and name are parameters
    std::cout << car.model << '\n';
    std::cout << car.year << '\n';
    std::cout << car.color << '\n';
}
void paintCar(Car &car, std::string color){
    car.color = color;
}


//Enums
enums --- a user-defined data type that consists of paired named-integer contants.
        GREAT if you have a set of potential options

#include <iostream>

enum Day {sunday = 0, monday = 1, tuesday = 2, wednesday = 3,
                    thursday = 4, friday = 5, saturday = 6};

int main () {

    Day today = friday;

    switch(today){          //We cannot assign strings in swicth(it only accepts int) But with enum it is possible
        case sunday:    std::cout << "It is Sunday!\n";
                        break;
        case monday:    std::cout << "It is Monday!\n";
                        break;
        case tuesday:   std::cout << "It is Tuesday!\n";
                        break;
        case wednesday: std::cout << "It is Wednesday!\n";
                        break;
        case thursday:  std::cout << "It is Thursday!\n";
                        break;
        case friday:    std::cout << "It is Friday!\n";
                        break;
        case saturday:  std::cout << "It is Saturday!\n";
                        break;
    }

    return 0;
}


// Objects and Classes
object ---- A collection of attributes and methods
            They can have charachteristics and could perform actions
            Can be used to mimic real world items (ex. Phone, Book, Animal etc)
            Created from a class which acts as a "blue-print"


#include <iostream>

class Car{
    public:
        std::string make;
        std::string model;
        int year;
        std::string color;

        void accelerate(){
            std::cout << "You step on the gas!\n";
        }
        void brake(){
            std::cout << "You step on the brakes!\n";
        }
};

int main() {

    Car car1;       

    car1.make = "Ford";
    car1.model = "Mustang";
    car1.year = 2023;
    car1.color = "silver";                      //Pretty same as structs but we can also add methods in class and objects

    std::cout << car1.make << '\n';
    std::cout << car1.model << '\n';
    std::cout << car1.year << '\n';
    std::cout << car1.color << '\n';

    car1.accelerate();
    car1.brake();

    return 0;
}


// Constructor
//constructor =  special method that is automatically called when an object is instantiated
	//                      useful for assigning values to attributes as arguments

#include <iostream>

class Car{
    public:
        std::string make;
        std::string model;
        int year;
        std::string color;

    Car(std::string make, std::string model, int year, std::string color){
        this->make = make;
        this->model = model;
        this->year = year;
        this->color = color;
    }
};

int main() {

    Car car1("Chevy", "Corvette", 2022, "blue");
    Car car2("Ford", "Mustang", 2023, "red");

    std::cout << car1.make << '\n';
    std::cout << car1.model << '\n';
    std::cout << car1.year << '\n';
    std::cout << car1.color << '\n';

    return 0;
}


// Constructor Overloading
overloaded constructors --- multiple constructors with same name but different parameters 
                            allows for varying arguments when instantiating an object

#include <iostream>

class Pizza{
    public:
        std::string topping1;
        std::string topping2;

    Pizza(){
        
    }
    Pizza(std::string topping1){
        this->topping1 = topping1;
    }
    Pizza(std::string topping1, std::string topping2){
        this->topping1 = topping1;
        this->topping2 = topping2;
    }
};

int main() {

    Pizza pizza1("pepperoni");
    Pizza pizza2("mushrooms", "peppers");
    Pizza pizza3;

    return 0;
}

// getters and setters
Abstraction --- hiding unnecessary data from ouside of the class
getter  ----   function that makes a private attribute READABLE
setter  ----   function that makes a private attribute WRITEABLE


#include <iostream>

class Stove{
    private:
        int temperature = 0;                        //private cannot be accessed ouside of the class. To access we use getter and setter

    public:

    int getTemperature(){
        return temperature;                         //only READABLE
    }
    void setTemperature(int temperature){           //WRITEABLE
        if(temperature < 0){
            this->temperature = 0;
        }
        else if(temperature >= 10){
            this->temperature = 10;
        }
        else{
            this->temperature = temperature;
        }
    }
};

int main() {

    Stove stove;

    stove.setTemperature(5);

    std::cout << "The temperature setting is: " << stove.getTemperature();

    return 0;
}


//Inheritence
Inheritence ----- A class can receive attributes and methods from another class 
                    Cildren classes inherit from a Parent class
                    Helps to reuse similar code found within multiple classes


#include <iostream>

class Animal{
    public:
        bool alive = true;
        
    void eat(){
        std::cout << "This animal is eating\n";
    }
};
class Dog : public Animal{                     //This Dog class inherit from Animal Class
    public:

    void bark(){
        std::cout << "The dog goes woof!\n";
    }
};
class Cat : public Animal{
    public:

    void meow(){
        std::cout << "The cat goes meow!\n";
    }
};

int main() {

    Dog dog;
    Cat cat;

    std::cout << dog.alive << '\n';
    
    dog.eat();
    dog.bark();

    std::cout << cat.alive << '\n';

    cat.eat();
    cat.meow();


    return 0;
}	    
